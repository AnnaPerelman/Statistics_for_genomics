---
title: "Lab 5: RNA-seq differential expression analysis"
author: "Leslie Myint"
date: "April 26, 2016"
package: "`r pkg_ver('BiocStyle')`"
output: 
  BiocStyle::html_document
---

# Overview

We will go over three widely used RNA-seq differential expression packages available in Bioconductor.

# Obtaining count matrices

Very often we'll start with fastq files that we'll align with a spliced aligner such as TopHat to get a SAM/BAM file. Let's look at how to obtain a matrix of count information with samples along the columns and genes/transcripts along the rows.

I downloaded the S. cerevisiae GTF file from Ensembl: [ftp://ftp.ensembl.org/pub/release-84/gtf/saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.84.gtf.gz](ftp://ftp.ensembl.org/pub/release-84/gtf/saccharomyces_cerevisiae/Saccharomyces_cerevisiae.R64-1-1.84.gtf.gz). About the GTF file format: [http://useast.ensembl.org/info/website/upload/gff.html](http://useast.ensembl.org/info/website/upload/gff.html).

Let's first create a database of known transcripts in yeast with `makeTxDbFromGFF`:

```{r}
library(GenomicFeatures)
gtfFile <- list.files("~/gtf", full.names = TRUE)
yeastTxdb <- makeTxDbFromGFF(gtfFile, format = "gtf")
```

For each gene, we can obtain the exons overlapping that gene:

```{r}
ebg <- exonsBy(yeastTxdb, by = "gene") # by = "tx" for exons by transcript
```

We see that there are `r length(ebg)` genes in this list. Now let's count the number of reads mapping to each gene.

```{r}
library(GenomicAlignments)
bamfiles <- BamFileList(list.files("~/statgenomics/hw2/", pattern = "accepted.*.bam", full.names = TRUE))
summex <- summarizeOverlaps(features = ebg, reads = bamfiles, mode = "Union", ignore.strand = TRUE)
summary(assay(summex, "counts"))
```

The reference sequence names in my BAM file and the GTF file don't match.

```{r}
seqinfo(bamfiles)
seqinfo(ebg)
```

We can remap these names using the `renameSeqLevels` function in the `GenomeInfoDb` package.

```{r}
library(GenomeInfoDb)
newnames <- seqlevels(bamfiles)
names(newnames) <- seqlevels(ebg)
seqlevels(ebg)
ebg <- renameSeqlevels(ebg, newnames)
seqlevels(ebg)
```

Now we can retry the counting. More information on `summarizeOverlaps`: [http://bioconductor.org/packages/release/bioc/vignettes/GenomicAlignments/inst/doc/summarizeOverlaps.pdf](http://bioconductor.org/packages/release/bioc/vignettes/GenomicAlignments/inst/doc/summarizeOverlaps.pdf).

```{r}
summex <- summarizeOverlaps(features = ebg, reads = bamfiles, mode = "Union", ignore.strand = TRUE)
summary(assay(summex, "counts"))
```

# Set up data

We'll be looking at a dataset mentioned in section 4.2.3 of the edgeR user's guide. The study looks at gene expression in Arabidopsis thaliana in the presence of a mutant form of Pseudomonas syringae. The control group was exposed to a mock pathogen.

```{r eval=FALSE}
install.packages("NBPSeq")
```

The data in the `NBPSeq` package is stored in the `arab` object that is available with `data(arab)`.

```{r}
library(NBPSeq)
data(arab)
countmat <- arab
coldata <- data.frame(treatment = factor(rep(c(0,1), each = 3), levels = c(0,1), labels = c("mock", "hrcctreated")))
```

# DESeq

For a detailed workflow using the `DESeq2` package, see [http://www.bioconductor.org/help/workflows/rnaseqGene/](http://www.bioconductor.org/help/workflows/rnaseqGene/). 

We first create a `DESeqDataSet` object from the count matrix.

```{r}
library(DESeq2)
dds <- DESeqDataSetFromMatrix(countData = countmat, colData = coldata, design = ~treatment)
```

Let's see if we need to filter out genes from our dataset due to uniformly low counts.

```{r}
plot(density(log2(rowSums(counts(dds))+1)))
keep <- rowSums(counts(dds)) > 1
table(keep)
dds <- dds[keep,]
```

The regularized-logarithm (rlog) transform is a variance-stabilizing transformation that allows us to visualize the distance between samples with a PCA plot.

```{r}
rld <- rlog(dds)
plotPCA(rld, intgroup = "treatment")
```

We can perform differential expression analysis on the untransformed data with the `DESeq` function.

```{r}
dds <- DESeq(dds)
res <- results(dds)
res <- res[order(res$padj),]
head(res)
summary(res)
```

We can estimate and adjust for batch effects with a version of `sva` adapted for sequencing.

```{r}
library(sva)
dds <- DESeqDataSetFromMatrix(countData = countmat, colData = coldata, design = ~treatment)
dds <- estimateSizeFactors(dds)
dat <- counts(dds, normalized = TRUE)
idx <- rowSums(dat) > 1
dat <- dat[idx,]
modmatFull <- model.matrix(~treatment, colData(dds))
modmatNull <- model.matrix(~1, colData(dds))
svseq <- svaseq(dat, modmatFull, modmatNull)
ddssva <- dds
ddssva$SV1 <- svseq$sv
design(ddssva) <- ~ SV1 + treatment
ddssva <- DESeq(ddssva)
ressva <- results(ddssva)
ressva <- ressva[order(ressva$padj),]
head(ressva)
summary(ressva)
```

## Visualizing results

We can plot the actual sample counts for selected genes.

```{r fig.width=10,fig.height=8}
topGenes <- rownames(res)[order(res$padj)][1:10]
par(mfrow = c(2,5))
for (i in 1:10)
	plotCounts(dds, gene = topGenes[i], intgroup = "treatment")
```

Genes with an adjusted p value below the specified threshold will be colored red.

```{r}
par(mfrow = c(1,1))
plotMA(res, alpha = 0.05)
```

Genes with very low counts can cause spikes in the p-value distribution, so we can remove them to get a better picture of the overall distribution of p-values without such outliers.

```{r fig.width=8}
par(mfrow = c(1,2))
hist(res$pvalue)
hist(res$pvalue[res$baseMean > 1])
```

# edgeR

edgeR user's guide: [https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf](https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf)

```{r}
library(edgeR)
dge <- DGEList(counts = countmat, group = coldata$treatment)
```

Let's evaluate if filtering is needed. We'll keep genes that have at least one read per million (cpm) in at least one sample in each condition.

```{r}
keep <- rowSums(cpm(dge)[,1:3] > 1) >= 1 & rowSums(cpm(dge)[,4:6] > 1) >= 1
table(keep)
```

We'll subset the `dge` object given the above filtering, but we must also have the library sizes recalculated with `keep.lib.sizes = FALSE`.

```{r}
dge <- dge[keep, , keep.lib.sizes=FALSE]
```

We apply TMM normalization (trimmed mean of M-values).

```{r}
dge <- calcNormFactors(dge)
```

```{r}
design <- model.matrix(~treatment, data = coldata)
dge <- estimateDisp(dge, design)
fit <- glmQLFit(dge, design)
qlf <- glmQLFTest(fit, coef = 2)
topTags(qlf)
# To perform likelihood ratio tests:
fit <- glmFit(dge, design)
lrt <- glmLRT(fit, coef = 2)
topTags(lrt)
```

# voom

See Chapter 15 of limma user's guide: [https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf](https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf)

```{r}
library(limma)
library(edgeR)
dge <- DGEList(counts = countmat)
dge <- calcNormFactors(dge)
design <- model.matrix(~disease, data = coldata)
v <- voom(dge, design, plot = FALSE)
fit <- lmFit(v, design)
fit <- eBayes(fit)
toptab <- topTable(fit, coef = 2, number = Inf)
```

```{r}
vqw <- voomWithQualityWeights(dge, design = design, normalization = "none", plot = FALSE)
vfit2 <- lmFit(vqw)
vfit2 <- eBayes(vfit2)
toptab2 <- topTable(vfit2, coef = 2, number = Inf)
```

# Points to keep in mind

* Make note of when you make choices in your analysis. How sensitive are your final results to that choice? It may be worthwhile to run a sensitivity analysis on that parameter. How stable is the ranking of top differentially expressed genes?